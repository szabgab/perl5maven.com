=title Скалярные переменные
=timestamp 2013-04-20T17:45:56
=indexes strict, my, undef, say, +, x, ., sigil, $, @, %, FATAL warnings
=status show
=original scalar-variables
=books beginner_book
=author szabgab
=translator spidamoo
=archive 1
=comments 1
=social 1

=abstract start

В этой части <a href="/perl-tutorial">Учебника Perl</a> мы рассмотрим структуры данных, существующие
в Perl и узнаем, как их использовать.

В Perl 5 есть 3 основных структуры данных. Это <b>скаляры, массивы и хэши</b>. Последние также 
могут называться как словари, справочные таблицы или ассоциативные массивы в других языках.

=abstract end

Перед переменными в Perl всегда ставится знак, называемый <b>"сигил"</b>. Этими знаками являются 
<hl>$</hl> для скаляров, <hl>@</hl> для массивов, и <hl>%</hl> для хэшей.

Скаляр может содержать единичное значение, например число или строку. Также он может содержать 
ссылку на другую структуру данных, к чему мы обратимся позже.

Название скалярной переменной всегда начинается с <hl>$</hl> (знак доллара), за которым следуют 
буквы, числа и подстрочия. В качестве названия переменной может использоваться <hl>$name</hl> или 
<hl>$long_and_descriptive_name</hl>. Также встречается вариант <hl>$LongAndDescriptiveName</hl>,
который обычно называют "CamelCase", но в Perl-сообществе обычно предпочитают названия, состоящие
только из символов нижнего регистра, с подстрочиями, отделяющими слова.

Поскольку мы всегда используем <b>strict</b>, нам всегда нужно объявлять переменные с помощью 
<b>my</b>. (Позже вы также узнаете об <b>our</b> и некоторых других способах, но пока что будем
использовать только объявление через <b>my</b>.) Мы можем либо присвоить переменной значение сразу,
как в этом примере:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $name = "Foo";
say $name;
</code>

либо сначала объявить ее, а присвоить значение позже:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $name;

$name = "Foo";
say $name;
</code>

Предпочтительно использовать первый способ, если логика кода позволяет.

Если мы объявили переменную, но еще не присвоили ей значение, она содержит значение, называемое
<a href="/undef-i-defined-v-perl">undef</a>, которое схоже с <b>NULL</b> в базах данных, но имеет
немного отличающееся поведение.

Можно проверить, является ли переменная <hl>undef</hl> с помощью функции <hl>defined</hl>:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $name;

if (defined $name) {
  say 'defined';
} else {
  say 'NOT defined';
}

$name = "Foo";

if (defined $name) {
  say 'defined';
} else {
  say 'NOT defined';
}

say $name;
</code>

Можно присвоить для скалярной переменной значение <hl>undef</hl>:

<code lang="perl">
$name = undef;
</code>

Скалярные переменные могут содержать числа или строки. То есть я могу написать:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $x = "hi";
say $x;

$x = 42;
say $x;
</code>

и это сработает.

Как это работает вместе с операторами и перегрузкой операторов в Perl?

По большей части Perl устроен диаметрально противоположно другим языкам. Вместо того, чтобы операнды
определяли, как работают операторы, оператор определяет, как ведут себя операнды.

Так что, если у меня есть две переменные, содержащие числа, оператор в итоге решает, будут ли они
восприниматься как числа или как строки:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = 2;
say $z;             # 2
my $y = 4;
say $y;             # 4

say $z + $y;        # 6
say $z . $y;        # 24
say $z x $y;        # 2222
</code>

<hl>+</hl>, оператор числового сложения, прибавляет два числа, так что и <hl>$y</hl> и <hl>$z</hl> 
ведут себя как числа.

<hl>.</hl>, оператор конкатенации строк, так что <hl>$y</hl> и <hl>$z</hl> ведут себя как строки. (В
других языках это бы могло называться строковым сложением.)

<hl>x</hl>, оператор повторения, повторяет строку слева количества раз, определяемое числом справа, 
так что в этом случае <hl>$z</hl> действует как строка, а <hl>$y</hl> - как число.

Результаты были бы теми же, если бы обе переменные создавались как строки:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = "2";
say $z;             # 2
my $y = "4";
say $y;             # 4

say $z + $y;        # 6
say $z . $y;        # 24
say $z x $y;        # 2222
</code>

И даже если одна из них создана как число, а вторая как строка:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = 7;
say $z;             # 7
my $y = "4";
say $y;             # 4

say $z + $y;        # 11
say $z . $y;        # 74
say $z x $y;        # 7777
</code>

Perl автоматически конвертирует числа в строки и наоборот, как того требует оператор.

Мы называем это числовым и строковым <b>контекстом</b>.

Вышеупомянутые случаи довольно просты. Преобразование числа в строку - по сути просто заключение его
в кавычки. Преобразование строки в числа, когда она состоит только из цифр - простой случай. То же 
будет, если в ней присутствует десятичная точка, например <hl>"3.14"</hl>. Вопрос в том, что если
в строке содержатся символы, не образующие число? Например <hl>"3.14 is pi"</hl>. Как тогда она себя
поведет в числовых операциях (то есть в числовом контексте)?

Это тоже несложно, хотя может потребовать некоторого объяснения.

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = 2;
say $z;             # 2
my $y = "3.14 is pi";
say $y;             # 3.14 is pi

say $z + $y;        # 5.14
say $z . $y;        # 23.14 is pi
say $z x $y;        # 222
</code>

Когда строка попадает в числовой контекст, Perl смотрит на левую часть строки, и пытается превратить
ее в число. Пока это получается, эта часть становится числовым значением переменной. В числовом 
контексте (<hl>+</hl>) строка <hl>"3.14 is pi"</hl> считается числом <hl>3.14</hl>.

В каком-то смысле это совершеннейший прозвол, но так это работает, так что мы живем с этим.


The above code will also generate a warning on the standard error channel (<hl>STDERR</hl>):

<code>
Argument "3.14 is pi" isn't numeric in addition(+) at example.pl line 10.
</code>

assuming you used <b>use warnings</b> which is highly recommended.
Using it will help you notice when something is not exactly as expected.
Hopefully the result of <hl>$x + $y</hl> is now clear.

<h2>Background</h2>

To be sure, perl did not convert <hl>$y</hl> to 3.14. It just used the numerical
value for the addition.
This probably explains the result of <hl>$z . $y</hl> as well.
In that case perl is using the original string value.

You might wonder why <hl>$z x $y</hl> shows 222 while we had 3.14 on the right hand side,
but apparently perl can only repeat a string along whole numbers... In the operation
perl silently rounds the number on the right hand side. (If you are really into
deep thinking, you can recognize that the "number" context mentioned earlier has actually
several sub-contexts, one of them is "integer" context. In most cases perl does what
would seem "the right thing" for most people who are not programmers.)

Not only that, but we don't even see the warning of the
"partial string to number" conversion that we saw in the case of <hl>+</hl>.

This is not because the difference in the operator. If we comment out the addition
we will see the warning on this operation. The reason for the lack of a second warning
is that when perl generated the numerical value of the string <hl>"3.14 is pi"</hl> it
also stored it in a hidden pocket of the <hl>$y</hl> variable. So effectively <hl>$y</hl>
now holds both a string value and a number value, and will use the right one in any
new operation avoiding the conversion.

There are three more things I'd like to address. One is the behavior of a variable with
<hl>undef</hl> in it, the other one is <b>fatal warnings</b> and the third one is avoiding
the automatic "string to number conversion".

<h2>undef</h2>

If in a variable I have <hl>undef</hl> which most people would refer to as "nothing", it can still be used.
In numerical context it will act as 0 in string context it will act as the empty string:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = 3;
say $z;        # 3
my $y;

say $z + $y;   # 3
say $z . $y;   # 3

if (defined $y) {
  say "defined";
} else {
  say "NOT";          # NOT
}
</code>

With two warnings:

<code>
Use of uninitialized value $y in addition (+) at example.pl line 9.

Use of uninitialized value $y in concatenation (.) or string at example.pl line 10.
</code>

As you can see the variable is still <hl>undef</hl> at the end and thus the conditional
will print "NOT".


<h2>Fatal warnings</h2>

The other thing is that some people prefer that the application will throw a
hard exception instead of the soft warning. If that's your thing, you could change the beginning of the script and write

<code lang="perl">
use warnings FATAL => "all";
</code>

Having that in the code, the script will print the number 3, and then throw an exception:

<code>
Use of uninitialized value $y in addition (+) at example.pl line 9.
</code>

This is the same message as was the first warning, but this time the script stops running.
(Unless, of course the exception is caught, but we'll talk about that another time.)

<h2>Avoiding the automatic string to number conversion</h2>

If you would like to avoid the automatic conversion of strings when there is no exact conversion,
you could check if the string looks like a number when you receive it from the outside world.

For this we are going to load the module <a href="https://metacpan.org/module/Scalar::Util">Scalar::Util</a>,
and use the subroutine <hl>looks_like_number</hl> it supplies.

<code lang="perl">
use strict;
use warnings FATAL => "all";
use 5.010;

use Scalar::Util qw(looks_like_number);

my $z = 3;
say $z;
my $y = "3.14";

if (looks_like_number($z) and looks_like_number($y)) {
  say $z + $y;
}

say $z . $y;

if (defined $y) {
  say "defined";
} else {
  say "NOT";
}
</code>


<h2>operator overloading</h2>

Finally, you could actually have operator overloading in which case
the operands would tell what the operators should do, but let's
leave that as an advanced topic.


