=title Автоматический перевод строк в числа или приведение типов в Perl
=timestamp 2013-07-10T12:00:00
=indexes is_number, looks_like_number, Scalar::Util, casting, type conversion
=status show
=original automatic-value-conversion-or-casting-in-perl
=books beginner_book
=author szabgab
=translator spidamoo
=archive 1
=comments 1
=social 1

=abstract start

Представьте, что, составляя список покупок, пишете на листке

<code>
"2 буханки хлеба"
</code>

и отдаете его своей второй половине, которая тут же выбрасывает ошибку неправильного перевода
типов прямо вам в лицо. Ведь, действительно, "2" здесь - это строка, а не число.

Это было бы то еще разочарование, не правда ли?

=abstract end

<h2>Перевод типов в Perl</h2>

В большинсте языков программирования тип операнда определяет поведение оператора.
То есть <i>прибавление</i> одного числа к другому выполнится как числовое сложение, 
а <i>прибавление</i> двух строк - как конкатенация. Это свойство называется перегрузкой операторов.

Perl по большей части работает наоборот.

В Perl оператор определяет, как будут использоваться операнды.

Таким образом, если вы используете числовую операцию (например, сложение), то оба значения
автоматически преобразуются в числа. Если вы используете строковую операцию (например, конкатенацию),
оба значения автоматически преобразуются в строки.

C-программисты, должно быть, назовут эти преобразования приведением типов, но это выражение не
используется в мире Perl. Возможно, потому, что все происходит само собой.

Для Perl'а не важно, пишете вы что-то как строку или как число. Он конвертирует их друг в друга
автоматически, основываясь на контексте.

Преобразование <h1>число => строка</h1> это просто. Мы просто представляем, что вокруг числа
появляются кавычки "".

Преобразование <h1>строка => число</h1> может немного озадачить. Если строка выглядит для perl'а как
число, то все просто. Числовое значение будет тем же самым, только без кавычек.

Если же встречается символ, который не дает perl'у полностью превратить строку в число, то он 
использует как число столько, сколько сможет, из левой части строки, и проигнорирует остальное.

Позвольте продемонстрировать вам пару примеров:

<code>
Исходное значение   Строка   Число

       42           "42"      42
       0.3          "0.3"     0.3
       "42"         "42"      42
       "0.3"        "0.3"     0.3

       "4z"         "4z"      4        (*)
       "4z3"        "4z3"     4        (*)
       "0.3y9"      "0.3y9"   0.3      (*)
       "xyz"        "xyz"     0        (*)
       ""           ""        0        (*)
       "23\n"       "23\n"    23
</code>

Во всех случаях, когда перевод строки в число не полон, кроме последнего, perl выдаст предупреждение.
Ну, предполагается, что вы включили <hl>use warnings</hl> в соответствии с рекомендациями.

<h2>Пример</h2>

Теперь давайте посмотрим в коде то, что вы видели в таблице:

<code lang="perl">
use strict;
use warnings;

my $x = "4T";
my $y = 3;

</code>

Конкатенация превращает оба значения в строки:

<code lang="perl">
print $x . $y;    # 4T3
</code>

Сложение превращает оба значения в числа:

<code lang="perl">
print $x + $y;  # 7
                # Argument "4T" isn't numeric in addition (+) at ...
</code>

<h2>Argument isn't numeric</h2>

Это предупреждение, которое вы получите, когда perl попытается конвертировать строку в число, но
перевод не полон.

Существуют некоторые других распространенных предупреждений и ошибок в Perl.
Например, <a href="/global-symbol-requires-explicit-package-name">Global symbol requires explicit package name</a>
и <a href="/use-of-uninitialized-value">Use of uninitialized value</a>.

<h2>Как избавиться от предупреждения?</h2>

Это приятно, что perl предупреждает вас (если попросить), когда перевод типов не полон, но
нет ли функции вроде <b>is_number</b>, которая проверит, является ли данная строка числом?

Да и нет.

В Perl нет функции <b>is_number</b>, потому что это стало бы заявлением, будто бы программисты Perl
знают, что является числом, а что нет. К сожалению, остальная часть мипа не может прийти к 
окончательному соглашению по этому вопросу. Существуют системы, в которых строка ".2" признается 
числом, но в других системах она таковым не является. Еще более простой случай - "2.", как 
правило, не признается, но есть система, в которой это совершенно допустимое число.

Есть даже места, где 0xAB считается числом. Шестнадцатеричным.

Так что функции <b>is_number</b> не существует, но есть менее категоричные функции, такие как 
<b>looks_like_number</b>.

Это именно то, что вы думаете. Функция проверит, будет ли данная строка похожа на число для perl'а.

Она содержится в модуле <a href="http://perldoc.perl.org/Scalar/Util.html">Scalar::Util</a> и ее
используют следующим образом:

<code lang="perl">
use strict;
use warnings;

use Scalar::Util qw(looks_like_number);

print "Сколько буханок хлеба мне купить? ";
my $loaves = <STDIN>;
chomp $loaves;

if (looks_like_number($loaves)) {
    print "Я пошел...\n";
} else {
    print "Извини, я не понял\n";
}
</code>


И не забудь молоко!


