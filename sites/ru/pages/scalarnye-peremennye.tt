=title Скалярные переменные
=timestamp 2013-09-20T10:00:01
=indexes strict, my, undef, say, +, x, ., sigil, $, @, %, FATAL warnings
=status show
=original scalar-variables
=books beginner_book
=author szabgab
=translator spidamoo
=archive 1
=comments 1
=social 1

=abstract start

В этой части <a href="/perl-tutorial">Учебника Perl</a> мы рассмотрим структуры данных, существующие
в Perl и узнаем, как их использовать.

В Perl 5 есть 3 основных структуры данных. Это <b>скаляры, массивы и хэши</b>. Последние также 
могут называться как словари, справочные таблицы или ассоциативные массивы в других языках.

=abstract end

Перед переменными в Perl всегда ставится знак, называемый <b>"сигил"</b>. Этими знаками являются 
<hl>$</hl> для скаляров, <hl>@</hl> для массивов, и <hl>%</hl> для хэшей.

Скаляр может содержать единичное значение, например число или строку. Также он может содержать 
ссылку на другую структуру данных, к чему мы обратимся позже.

Название скалярной переменной всегда начинается с <hl>$</hl> (знак доллара), за которым следуют 
буквы, числа и подстрочия. В качестве названия переменной может использоваться <hl>$name</hl> или 
<hl>$long_and_descriptive_name</hl>. Также встречается вариант <hl>$LongAndDescriptiveName</hl>,
который обычно называют "CamelCase", но в Perl-сообществе обычно предпочитают названия, состоящие
только из символов нижнего регистра, с подстрочиями, отделяющими слова.

Поскольку мы всегда используем <b>strict</b>, нам всегда нужно объявлять переменные с помощью 
<b>my</b>. (Позже вы также узнаете об <b>our</b> и некоторых других способах, но пока что будем
использовать только объявление через <b>my</b>.) Мы можем либо присвоить переменной значение сразу,
как в этом примере:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $name = "Foo";
say $name;
</code>

либо сначала объявить ее, а присвоить значение позже:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $name;

$name = "Foo";
say $name;
</code>

Предпочтительно использовать первый способ, если логика кода позволяет.

Если мы объявили переменную, но еще не присвоили ей значение, она содержит значение, называемое
<a href="/undef-i-defined-v-perl">undef</a>, которое схоже с <b>NULL</b> в базах данных, но имеет
немного отличающееся поведение.

Можно проверить, является ли переменная <hl>undef</hl> с помощью функции <hl>defined</hl>:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $name;

if (defined $name) {
  say 'defined';
} else {
  say 'NOT defined';
}

$name = "Foo";

if (defined $name) {
  say 'defined';
} else {
  say 'NOT defined';
}

say $name;
</code>

Можно присвоить для скалярной переменной значение <hl>undef</hl>:

<code lang="perl">
$name = undef;
</code>

Скалярные переменные могут содержать числа или строки. То есть я могу написать:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $x = "hi";
say $x;

$x = 42;
say $x;
</code>

и это сработает.

Как это работает вместе с операторами и перегрузкой операторов в Perl?

По большей части Perl устроен диаметрально противоположно другим языкам. Вместо того, чтобы операнды
определяли, как работают операторы, оператор определяет, как ведут себя операнды.

Так что, если у меня есть две переменные, содержащие числа, оператор в итоге решает, будут ли они
восприниматься как числа или как строки:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = 2;
say $z;             # 2
my $y = 4;
say $y;             # 4

say $z + $y;        # 6
say $z . $y;        # 24
say $z x $y;        # 2222
</code>

<hl>+</hl>, оператор числового сложения, прибавляет два числа, так что и <hl>$y</hl> и <hl>$z</hl> 
ведут себя как числа.

<hl>.</hl>, оператор конкатенации строк, так что <hl>$y</hl> и <hl>$z</hl> ведут себя как строки. (В
других языках это бы могло называться строковым сложением.)

<hl>x</hl>, оператор повторения, повторяет строку слева количества раз, определяемое числом справа, 
так что в этом случае <hl>$z</hl> действует как строка, а <hl>$y</hl> - как число.

Результаты были бы теми же, если бы обе переменные создавались как строки:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = "2";
say $z;             # 2
my $y = "4";
say $y;             # 4

say $z + $y;        # 6
say $z . $y;        # 24
say $z x $y;        # 2222
</code>

И даже если одна из них создана как число, а вторая как строка:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = 7;
say $z;             # 7
my $y = "4";
say $y;             # 4

say $z + $y;        # 11
say $z . $y;        # 74
say $z x $y;        # 7777
</code>

Perl автоматически конвертирует числа в строки и наоборот, как того требует оператор.

Мы называем это числовым и строковым <b>контекстом</b>.

Вышеупомянутые случаи довольно просты. Преобразование числа в строку - по сути просто заключение его
в кавычки. Преобразование строки в числа, когда она состоит только из цифр - простой случай. То же 
будет, если в ней присутствует десятичная точка, например <hl>"3.14"</hl>. Вопрос в том, что если
в строке содержатся символы, не образующие число? Например <hl>"3.14 is pi"</hl>. Как тогда она себя
поведет в числовых операциях (то есть в числовом контексте)?

Это тоже несложно, хотя может потребовать некоторого объяснения.

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = 2;
say $z;             # 2
my $y = "3.14 is pi";
say $y;             # 3.14 is pi

say $z + $y;        # 5.14
say $z . $y;        # 23.14 is pi
say $z x $y;        # 222
</code>

Когда строка попадает в числовой контекст, Perl смотрит на левую часть строки, и пытается превратить
ее в число. Пока это получается, эта часть становится числовым значением переменной. В числовом 
контексте (<hl>+</hl>) строка <hl>"3.14 is pi"</hl> считается числом <hl>3.14</hl>.

В каком-то смысле это совершеннейший прозвол, но так это работает, так что мы живем с этим.

Код выше также выдаст предупреждение в стандартный канал ошибок (<hl>STDERR</hl>):

<code>
Argument "3.14 is pi" isn't numeric in addition(+) at example.pl line 10.
</code>

в случае, если вы использовали <b>use warnings</b>, что настоятельно рекомендуется. Использование
предупреждений поможет заметить, если что-то пойдет не совсем так, как предполагалось. Надеюсь,
результат выполнения <hl>$x + $y</hl> теперь вполне ясен.

<h2>За кадром</h2>

На всякий случай, perl не конвертирует <hl>$y</hl> в 3.14, он просто использует числовое значение
для сложения. Думаю, это объясняет и результат <hl>$z . $y</hl>. В этом случае perl использует 
исходное строковое значение.

Возможно, вы удивлены, что <hl>$z x $y</hl> выдает 222, хотя справа у нас 3.14. Дело в том, что perl
может повторить строку только целое число раз... В этой операции perl молча округляет число справа.
(Если задуматься, можно понять, что "числовой" контекст, о котором шла речь раньше, на самом деле
включает в себя несколько подконтекстов, один из которых - "целочисленный". В большинстве случаев
perl делает то, что подсказывает здравый смысл большинству людей-непрограммисов)

Кроме того, мы даже не видим предупреждения "partial string to number conversion", как в случае с 
<hl>+</hl>.

Это не из-за другого оператора. Если закомментировать сложение, мы увидим это предупреждение уже на
этой операции. Причина отсутствия второго предупреждения в том, что когда perl создал числовое 
значение строки <hl>"3.14 is pi"</hl>, он сохранил его в потайном кармане переменной <hl>$y</hl>.
Так что по сути <hl>$y</hl> с тех пор имеет и строковое, и числовое значение, и нужное будет 
использоваться в соответствующие моменты уже без преобразования.

Есть еще три вещи, которые я хотел бы упомянуть. Первая это поведение переменной со значением 
<hl>undef</hl>, вторая - <b>fatal warnings</b>, и третья - как избежать автоматического перевода
строк в числа.

<h2>undef</h2>

Если у меня в переменной содержится <hl>undef</hl>, что для большинства значит "ничего", ее все 
равно можно использовать. В числовом контексте она будет 0, а в строковом - пустой строкой:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = 3;
say $z;        # 3
my $y;

say $z + $y;   # 3
say $z . $y;   # 3

if (defined $y) {
  say "defined";
} else {
  say "NOT";          # NOT
}
</code>

С двумя предупреждениями:

<code>
Use of uninitialized value $y in addition (+) at example.pl line 9.

Use of uninitialized value $y in concatenation (.) or string at example.pl line 10.
</code>

Как можно видеть, в конце скриппта переменная все еще <hl>undef</hl>, так что условное выражение 
выдаст "NOT".

<h2>Fatal warnings</h2>

Второе, о чем я хотел сказать - некоторые предпочитают, чтобы приложение выбрасывало жесткое 
исключение вместо мягкого предупреждения. Если вы тоже исповедуете этот принцип, в начале скрипта
можно написать

<code lang="perl">
use warnings FATAL => "all";
</code>

С этим скрипт выведет число 3, а затем выбросит исключение:

<code>
Use of uninitialized value $y in addition (+) at example.pl line 9.
</code>

Это то же сообщение, которое раньше было предупреждением, но теперь после этого выполнение скрипта
останавливается. (Если, конечно, исключение не было поймано, но об этом мы поговорим в другой раз.)

<h2>Избежание автоматического перевода строки в число</h2>

Если вам не хочется, чтобы строки автоматически переводились в числа там, где невозможен полный 
перевод, вы можете проверять, выглядит ли строка как число, когда получаете ее из внешнего мира.

Для этого нам нужно подгрузить модуль 
<a href="https://metacpan.org/module/Scalar::Util">Scalar::Util</a> и содержащуюся в нем 
подпрограмму <hl>looks_like_number</hl>.

<code lang="perl">
use strict;
use warnings FATAL => "all";
use 5.010;

use Scalar::Util qw(looks_like_number);

my $z = 3;
say $z;
my $y = "3.14";

if (looks_like_number($z) and looks_like_number($y)) {
  say $z + $y;
}

say $z . $y;

if (defined $y) {
  say "defined";
} else {
  say "NOT";
}
</code>


<h2>перегрузка операторов</h2>

Наконец, можно перегрузить операторы так, чтобы операнды указывали, что должен делать оператор, но 
эту тему мы оставим в качестве продвинутой.

